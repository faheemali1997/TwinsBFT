# -*- generated by 1.0.14 -*-
import da
PatternExpr_379 = da.pat.TuplePattern([da.pat.ConstantPattern('Done')])
PatternExpr_384 = da.pat.BoundPattern('_BoundPattern385_')
PatternExpr_386 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.BoundPattern('_BoundPattern392_')]), da.pat.TuplePattern([da.pat.ConstantPattern('Done')])])
_config_object = {}
import os
import shutil
import sys
sys.path.append('../config')
from config import configs
from client import Client
from cryptography import Cryptography
from validator import ValidatorFI

class RunDiemBFT(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._RunDiemBFTReceivedEvent_0 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_RunDiemBFTReceivedEvent_0', PatternExpr_379, sources=[PatternExpr_384], destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, config, config_id, **rest_539):
        super().setup(config=config, config_id=config_id, **rest_539)
        self._state.config = config
        self._state.config_id = config_id
        self._state.nvalidators = int(self._state.config['nvalidators'])
        self._state.nclients = int(self._state.config['nclients'])
        self._state.nfaulty = int(self._state.config['nfaulty'])

    def run(self):
        private_keys_validators = {}
        public_keys_validators = {}
        private_keys_clients = {}
        public_keys_clients = {}
        os.makedirs(('../logs/config' + str(self._state.config_id)))
        os.makedirs(('../ledgers/config' + str(self._state.config_id)))
        validators = self.new(ValidatorFI, num=self._state.nvalidators)
        clients = self.new(Client, num=self._state.nclients)
        for v in validators:
            (private_key, public_key) = Cryptography.generate_key()
            private_keys_validators[v] = private_key
            public_keys_validators[v] = public_key
        for c in clients:
            (private_key, public_key) = Cryptography.generate_key()
            private_keys_clients[c] = private_key
            public_keys_clients[c] = public_key
        for (i, v) in enumerate(validators):
            self._setup({v}, (self._state.config, self._state.config_id, i, list(validators), list(clients), private_keys_validators[v], public_keys_validators, public_keys_clients))
        for (i, c) in enumerate(clients):
            self._setup({c}, (self._state.config, self._state.config_id, i, list(validators), private_keys_clients[c], public_keys_validators))
        self._start(validators)
        self._start(clients)
        super()._label('_st_label_371', block=False)
        c = None

        def UniversalOpExpr_372():
            nonlocal c
            for c in clients:
                if (not PatternExpr_386.match_iter(self._RunDiemBFTReceivedEvent_0, _BoundPattern392_=c, SELF_ID=self._id)):
                    return False
            return True
        _st_label_371 = 0
        while (_st_label_371 == 0):
            _st_label_371 += 1
            if UniversalOpExpr_372():
                _st_label_371 += 1
            else:
                super()._label('_st_label_371', block=True)
                _st_label_371 -= 1
        self.output('All clients done, informing all validators.', self._state.config_id)
        self.send(('Done',), to=validators)

def is_config_valid(config):
    if (int(config['nvalidators']) < ((3 * int(config['nfaulty'])) + 1)):
        print('Number of validators should be more than thrice of number of faulty validators.')
        return False
    if ((int(config['nfaulty']) > int(config['exclude_size'])) or (int(config['exclude_size']) > (2 * int(config['nfaulty'])))):
        print('Exlude size should be between nfaulty and 2*nfaulty')
        return False
    return True

class Node_(da.NodeProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._events.extend([])

    def run(self):
        if (os.path.exists('../logs/') and os.path.isdir('../logs/')):
            shutil.rmtree('../logs/')
        if (os.path.exists('../ledgers/') and os.path.isdir('../ledgers/')):
            shutil.rmtree('../ledgers/')
        config_id = 0
        for config in configs:
            if (not is_config_valid(config)):
                self.output('The provided config', config, 'is not valid. Skipping this config.')
                continue
            p = self.new(RunDiemBFT)
            self._setup(p, (config, config_id))
            self._start(p)
            config_id += 1
