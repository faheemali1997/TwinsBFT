"""
1a. Two(Twins) leaders send Proposal message to network hub
    - If both twins are in same partition:
        - Send to all nodes with normal node as leader within that partition
    - If both are in different partition
        - Send from both twins to all nodes in those partitions, sending sender as normal node
1b. Leader is non byzentine,
    - Send to only nodes within that partition,rest drop messages

=========================Next Leader Election happens==========================================

1a.

1 :Two(Twins) leaders send Proposal message to network hub
2: If both twins are in same partition:
   Send to all nodes with normal node as leader
"""
# if twins are leaders and they send proposals and if twins are leaders in the next round then the twin should send vote only to itself and not the other twin

import json
import sys
from collections import defaultdict

sys.path.append('../../generator/testcase_1.json')

class NetworkHub(process):

    def setup(test_case, validators_map: dict, test_case_scenario, dist_algo_id_to_virtual_id_map):

        self.number_of_nodes = int(test_case['number_of_nodes'])
        self.number_of_twins = int(test_case['number_of_twins'])
        self.twins = test_case['twins']
        self.process_ids = validators_map
        self.blocked = {}
        self.test_case_scenario = test_case_scenario
        self.round_leaders = test_case_scenario['round_leaders']
        self.partitions = test_case_scenario['partitions']
        self.random_message_drops = test_case_scenario['random_message_drops']
        self.partitions_per_round = get_partition_per_round(test_case_scenario)
        self.round_leaders_per_round = get_round_leaders(test_case_scenario)
        self.random_message_drops_per_round = get_random_message_drops(test_case_scenario)
        self.dist_algo_id_to_virtual_id_map = dist_algo_id_to_virtual_id_map

    # Network hub receives all the proposal messages and then decides whether to forward or not.
    # if should_send_proposal_msg(p,d,round_no):

    def run():

        await(False)

    def receive(msg=('Proposal', proposal_msg, dest), from_=p):

        #List of distalgo process id for destinations
        destinations = dest

        #round number
        round_no = proposal_msg.block.round

        for d in destinations:

            output("SENDING")
            send(('Proposal', proposal_msg, p), to=d)

    def receive(msg=('Vote', vote_msg), from_=p):

        #List of distalgo process id for destinations
        destinations = vote_msg.dest

        #round number
        round_no = vote_msg.vote_info.round

        for d in destinations:

            if should_send_vote_msg(p,d,round_no):

                send(('Vote', vote_msg), to=d)

    def receive(msg=('Timeout', timeout_msg), from_=p):

        #List of distalgo process id for destinations
        destinations = timeout_msg.dest

        #round number
        round_no = timeout_msg.tmo_info.round

        for d in destinations:

            if should_send_timeout_msg(p,d,round_no):

                send(('Timeout', timeout_msg), to=d)

    def should_send_proposal_msg(p, d, round_no):

        virtual_p = self.dist_algo_id_to_virtual_id_map[p]

        virtual_d = self.dist_algo_id_to_virtual_id_map[d]

        # Below this point we only use virtual ids

        partitions = self.partitions_per_round[str(round_no)]

        message_drop = self.random_message_drops_per_round[str(round_no)]

        if message_drop and 'Proposal' in message_drop and virtual_p in message_drop and virtual_d in message_drop:
            return False

        for partition in partitions[0]:

            if p in partition and d in partition:
                return True

        return False

    def should_send_vote_msg(p, d, round_no):

        virtual_p = self.dist_algo_id_to_virtual_id_map[p]

        virtual_d = self.dist_algo_id_to_virtual_id_map[d]

        partitions = self.partitions_per_round[str(round_no)]

        message_drop = self.random_message_drops_per_round[str(round_no)]

        if message_drop and 'Vote' in message_drop and virtual_p in message_drop and virtual_d in message_drop:
            return False

        for partition in partitions[0]:

            if virtual_p in partition and virtual_d in partition:
                return True

        return False

    def should_send_timeout_msg(p, d, round_no):

        virtual_p = self.dist_algo_id_to_virtual_id_map[p]

        virtual_d = self.dist_algo_id_to_virtual_id_map[d]

        partitions = self.partitions_per_round[str(round_no)]

        message_drop = self.random_message_drops_per_round[str(round_no)]

        if message_drop and 'Timeout' in message_drop and virtual_p in message_drop and virtual_d in message_drop:
            return False

        for partition in partitions[0]:

            if virtual_p in partition and virtual_d in partition:
                return True

        return False

    # loop through array of partitions, partition[0] -> array of partitions
    def get_partition_per_round(test_case):
        ans = defaultdict(list)

        for k, v in test_case['partitions'].items():

            ans[k].append(v[0])

        return ans


    # starightforward, round_leaders[k] -> array
    def get_round_leaders(test_case):
        ans = defaultdict(list)

        for k, v in test_case['round_leaders'].items():
            ans[k].append(v)

        return ans


    def get_random_message_drops(test_case):
        ans = defaultdict(list)

        for k, v in test_case['random_message_drops'].items():

            if len(v) > 0:
                ans[k].append(v[0])

        return ans
