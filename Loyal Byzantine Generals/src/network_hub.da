"""
1a. Two(Twins) leaders send Proposal message to network hub
    - If both twins are in same partition:
        - Send to all nodes with normal node as leader within that partition
    - If both are in different partition
        - Send from both twins to all nodes in those partitions, sending sender as normal node
1b. Leader is non byzentine,
    - Send to only nodes within that partition,rest drop messages

=========================Next Leader Election happens==========================================

1a.

1 :Two(Twins) leaders send Proposal message to network hub
2: If both twins are in same partition:
   Send to all nodes with normal node as leader
"""
# if twins are leaders and they send proposals and if twins are leaders in the next round then the twin should send vote only to itself and not the other twin

import json
import sys
from collections import defaultdict
import traceback
import hashlib
import re
import os
from logger_util import LOGGER


BUF_SIZE = 65536  # lets read stuff in 64kb chunks!

sys.path.append('../../generator/testcase_1.json')

class NetworkHub(process):

    def setup(config, config_id, clients,validator_list,test_case, validators_map: dict, test_case_scenario, dist_algo_id_to_virtual_id_map):

        self.number_of_nodes = int(test_case['number_of_nodes'])
        self.number_of_twins = int(test_case['number_of_twins'])
        self.twins = test_case['twins']
        self.twins_process_ids = validators_map
        self.blocked = {}
        self.test_case_scenario = test_case_scenario
        self.round_leaders = test_case_scenario['round_leaders']
        self.partitions = test_case_scenario['partitions']
        self.random_message_drops = test_case_scenario['random_message_drops']
        self.partitions_per_round = get_partition_per_round(test_case_scenario)
        self.round_leaders_per_round = get_round_leaders(test_case_scenario)
        self.random_message_drops_per_round = get_random_message_drops(test_case_scenario)
        self.dist_algo_id_to_virtual_id_map = dist_algo_id_to_virtual_id_map
        self.validator_list = validator_list
        self.done = False
        self.config = config
        self.config_id = config_id
        self.clients = clients

        #LOGGER.replicas = replicas
        LOGGER.process_id = "network_hub"
        LOGGER.clients = clients
        LOGGER.filename = '../logs/config' + str(config_id) + '/' \
            + LOGGER.process_id + ".log"

        LOGGER.log_action("Initial configuration", config)

    # Network hub receives all the proposal messages and then decides whether to forward or not.
    # if should_send_proposal_msg(p,d,round_no):

    def run():
        LOGGER.log_action("Running Network Hub", {})
        await(self.done)

        output('Exiting here')

    def check_safety():
        LOGGER.log_action("Checking Safety: ", {})
        path = os.path.realpath('../') + '/ledgers' + '/' + 'config'+str(self.config_id)
        ledgers = os.listdir(path)
        ledger_hash = defaultdict(int)

        # Find the file with min size and find the longest common prefix same

        _min = ['', float('inf')]
        ledger_list = []
        for ledger in ledgers:
            with open(path + '/'+ledger) as f:
                s = ''.join(f.read().split('\n'))
                ledger_list.append(s)

        num_faulty = self.config['nfaulty']

        for li in ledger_list:

            count = 0

            for l in ledger_list:

                if l.startswith(li):
                    count += 1

            if count >= 2 * num_faulty + 1:
                return True

        return False

    def check_liveliness():
        LOGGER.log_action("Checking Liveliness: ", {})
        path = os.path.realpath('../') + '/ledgers' + '/' + 'config'+str(self.config_id)
        ledgers = os.listdir(path)

        threshold = 0.6 * self.config['nclients']

        threshold_count = 0

        for ledger in ledgers:
            ledger_path = path + '/' + '/' + ledger
            with open(ledger_path) as f:
                requests = f.read().split('\n')
                _set = set()
                for r in requests:
                    client = r.split('-')
                    _set.add(client[0])
                if len(_set) >= threshold:
                    threshold_count += 1

        return threshold_count >= 2 * self.config['nfaulty'] + 1

    def exit_if_valid(round_no):

        if round_no > int(max(self.round_leaders_per_round.keys())):
            # Check Safety and Liveliness
            safety = check_safety()
            lively = check_liveliness()
            # Sending Done to validators and clients
            send(('Done',), to=self.validator_list)
            send(('Done'), to=self.clients)
            output('Network Hub is exiting as maximum rounds reached ', round_no)
            with open('../ledgers/safety.txt', 'a') as f:
                f.write('config'+str(self.config_id)+' Safety: '+str(safety)+'\n')
            with open('../ledgers/liveliness.txt', 'a') as f:
                f.write('config'+str(self.config_id)+' Liveliness: '+str(lively)+'\n')
            self.done = True

    def receive(msg=('Proposal', proposal_msg, dest), from_=p):
        LOGGER.log_action("Received Proposal Msg from: ", {self.dist_algo_id_to_virtual_id_map[p]})
        try:

            #List of distalgo process id for destinations
            destinations = dest

            #round number
            round_no = proposal_msg.block.round

            exit_if_valid(round_no)

            for d in destinations:

                if self.should_send_proposal_msg(p, d, round_no):
                    output('Sending, successfully')
                    send(('Proposal', proposal_msg, p), to=d)
                    LOGGER.log_action("Sending Proposal Msg to: ", {self.dist_algo_id_to_virtual_id_map[d]})
                else:
                    output('Proposal Message Dropped')
                    LOGGER.log_action("Proposal Message Dropped: ", {self.dist_algo_id_to_virtual_id_map[d]})
                if p in self.twins_process_ids and self.should_send_proposal_msg(self.twins_process_ids[p],d,round_no):
                    output('Sending, successfully from twin')
                    send(('Proposal', proposal_msg, p), to=d)
                    LOGGER.log_action("Sending Proposal Msg from twin: ", {self.dist_algo_id_to_virtual_id_map[p]})

        except Exception:
            print(traceback.format_exc())

    def receive(msg=('Vote', vote_msg, dest), from_=p):
        LOGGER.log_action("Received Vote Msg from: ", {self.dist_algo_id_to_virtual_id_map[p]})
        try:

            #List of distalgo process id for destinations
            destinations = dest

            #round number
            round_no = vote_msg.vote_info.round

            exit_if_valid(round_no)

            for d in destinations:

                if should_send_vote_msg(p,d,round_no):
                    send(('Vote', vote_msg,p), to=d)
                    LOGGER.log_action("Vote Message Sent: ", {self.dist_algo_id_to_virtual_id_map[d]})
                else:
                    LOGGER.log_action("Vote Message Dropped: ", {self.dist_algo_id_to_virtual_id_map[d]})


        except Exception:
            print(traceback.format_exc())


    def receive(msg=('Timeout', timeout_msg, sender), from_=p):
        LOGGER.log_action("Timeout Message Received: ", {self.dist_algo_id_to_virtual_id_map[p]})
        try:

            #List of distalgo process id for destinations
            destinations = sender

            #round number
            round_no = timeout_msg.tmo_info.round

            exit_if_valid(round_no)

            LOGGER.log_action("Timeout Message Sent: ", {'Everyone'})
            send(('Timeout', timeout_msg, p), to=destinations)

        except Exception:
            print(traceback.format_exc())

    def should_send_proposal_msg(p, d, round_no):

        virtual_p = self.dist_algo_id_to_virtual_id_map[p]

        virtual_d = self.dist_algo_id_to_virtual_id_map[d]

        # Below this point we only use virtual ids

        partitions = self.partitions_per_round[str(round_no)]

        message_drop = self.random_message_drops_per_round[str(round_no)]

        if message_drop:
            message_drop = message_drop[0]

        # Intra partition message drop based on randomness and deterministic
        if message_drop and 'Proposal' in message_drop and virtual_p in message_drop and virtual_d in message_drop:
            output('Hey, I am dropping this message')
            return False


        if len(partitions) == 0:
            return True

        for partition in partitions[0]:
            if virtual_p in partition and virtual_d in partition:
                return True

        return False

    def should_send_vote_msg(p, d, round_no):

        virtual_p = self.dist_algo_id_to_virtual_id_map[p]

        virtual_d = self.dist_algo_id_to_virtual_id_map[d]

        partitions = self.partitions_per_round[str(round_no)]

        message_drop = self.random_message_drops_per_round[str(round_no)]

        if message_drop:
            message_drop = message_drop[0]

        if message_drop and 'Vote' in message_drop and virtual_p in message_drop and virtual_d in message_drop:
            return False

        if len(partitions) == 0:
            return True

        for partition in partitions[0]:

            if virtual_p in partition and virtual_d in partition:
                return True

        return False

    def should_send_timeout_msg(p, d, round_no):

        virtual_p = self.dist_algo_id_to_virtual_id_map[p]

        virtual_d = self.dist_algo_id_to_virtual_id_map[d]

        partitions = self.partitions_per_round[str(round_no)]

        message_drop = self.random_message_drops_per_round[str(round_no)]

        if message_drop:
            message_drop = message_drop[0]

        if message_drop and 'Timeout' in message_drop and virtual_p in message_drop and virtual_d in message_drop:
            return False

        if len(partitions) == 0:
            return True

        for partition in partitions[0]:

            if virtual_p in partition and virtual_d in partition:
                return True

        return False

    # loop through array of partitions, partition[0] -> array of partitions
    def get_partition_per_round(test_case):
        ans = defaultdict(list)

        for k, v in test_case['partitions'].items():

            ans[k].append(v[0])

        return ans


    # starightforward, round_leaders[k] -> array
    def get_round_leaders(test_case):
        ans = defaultdict(list)

        for k, v in test_case['round_leaders'].items():
            ans[k].append(v)

        return ans


    def get_random_message_drops(test_case):
        ans = defaultdict(list)

        for k, v in test_case['random_message_drops'].items():

            if len(v) > 0:
                ans[k].append(v[0])

        return ans
