import os
import shutil
import sys
import json

sys.path.append('../config')

sys.path.append('../../')

from client import Client
from config import configs
from cryptography import Cryptography
from validator import ValidatorFI
from generator import generator
from network_hub import NetworkHub

def get_twins(twins):

    ans = dict()

    if not twins:
        return ans

    for k,v in twins.items():
        ans[int(k)] = int(v)
        ans[int(v)] = int(k)

    return ans


class RunDiemBFT(process):

    def setup(config, config_id, twins,test_case, test_case_scenario):
        self.nvalidators = int(config['nvalidators'])
        self.nclients = int(config['nclients'])
        self.nfaulty = int(config['nfaulty'])
        # Virtual Index Twin Mapping
        self.twins = get_twins(twins)
        self.total_nodes = self.nvalidators + self.nfaulty
        # DistAlgo Twin Mapping
        self.twin_validator_mapping = dict()
        self.test_case = test_case
        self.test_case_scenario = test_case_scenario
        self.dist_algo_id_to_virtual_id_map = dict()

    def run():

        private_keys_validators = {}
        public_keys_validators = {}
        private_keys_clients = {}
        public_keys_clients = {}

        os.makedirs('../logs/config' + str(config_id))
        os.makedirs('../ledgers/config' + str(config_id))

        network_hub = new(NetworkHub, num=1)
        validators = new(ValidatorFI, num=total_nodes)
        clients = new(Client, num=nclients)

        validator_list = list(validators)

        # This will create a map of distalgo process ids vs virtual indexes
        for i, v in enumerate(list(validators)):
            self.dist_algo_id_to_virtual_id_map[v] = i

        for k,v in self.twins.items():
            self.twin_validator_mapping[validator_list[int(k)]] = validator_list[int(v)]
            self.twin_validator_mapping[validator_list[int(v)]] = validator_list[int(k)]

        for v in validators:
            v_twin = self.twin_validator_mapping.get(v,None)
            if v_twin is not None and v_twin in private_keys_validators:
                private_keys_validators[v] = private_keys_validators[v_twin]
                public_keys_validators[v] = public_keys_validators[v_twin]
                continue
            private_key, public_key = Cryptography.generate_key()
            private_keys_validators[v] = private_key
            public_keys_validators[v] = public_key

        for c in clients:
            private_key, public_key = Cryptography.generate_key()
            private_keys_clients[c] = private_key
            public_keys_clients[c] = public_key

        validators_new_list = list(validators)[::]

        if (self.nfaulty) > 0:
            validators_new_list = validators_new_list[:-self.nfaulty]

        for i, v in enumerate(validators):
            if i in self.twins:
                setup({v}, (config, config_id, min(i, self.twins[i]), validators_new_list, list(clients),
                        private_keys_validators[v], public_keys_validators, public_keys_clients, network_hub, self.test_case_scenario))
            else:
                setup({v}, (config, config_id, i, validators_new_list, list(clients),
                        private_keys_validators[v], public_keys_validators, public_keys_clients, network_hub, self.test_case_scenario))

        for i, c in enumerate(clients):
            setup({c}, (config, config_id, i,validators_new_list,
                        private_keys_clients[c], public_keys_validators))

        setup(network_hub, (self.test_case, self.twin_validator_mapping, self.test_case_scenario, self.dist_algo_id_to_virtual_id_map))

        start(network_hub)
        start(validators)
        start(clients)

        await(each(c in clients, has=received(('Done',), from_=c)))
        output("All clients done, informing all validators.", config_id)
        send(('Done',), to=validators)


def is_config_valid(config):
    if int(config['nvalidators']) < (3 * int(config['nfaulty']) + 1):
        print(
            "Number of validators should be more than thrice of number of faulty validators.")
        return False
    if (int(config['nfaulty']) > int(config['exclude_size'])) or (int(config['exclude_size']) > 2 * int(config['nfaulty'])):
        print(
            "Exlude size should be between nfaulty and 2*nfaulty")
        return False
    return True


def main():

    dir = '../testcases/'
    for f in os.listdir(dir):
        os.remove(os.path.join(dir, f))

    config_id = 0

    if os.path.exists('../logs/') and os.path.isdir('../logs/'):
        shutil.rmtree('../logs/')

    if os.path.exists('../ledgers/') and os.path.isdir('../ledgers/'):
        shutil.rmtree('../ledgers/')

    for config in configs:
        if not is_config_valid(config):
            output("The provided config", config,
                   "is not valid. Skipping this config.")
            continue

        output_file = config['output_file_name']

        gen = generator.TestGenerator(config)
        gen.run(True)

        with open('../testcases/'+output_file) as file:
            test_case = json.load(file)
            test_case_scenarios = test_case['test_case_scenarios']

        for test_case_scenario in test_case_scenarios:
            p = new(RunDiemBFT)
            setup(p, (config,config_id, test_case['twins'], test_case, test_case_scenario[0]))
            start(p)

        config_id += 1

